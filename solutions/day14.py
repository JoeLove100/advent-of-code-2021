from typing import Dict, Tuple, List, DefaultDict
from collections import defaultdict


def read_input(lines: List[str]) -> Tuple[str, Dict[str, str]]:
    """
    convert raw input lines to our start polymer chain
    and insertion mapping
    """

    polymer = lines[0].replace("\n", "")
    insertion_map = dict()
    for line in lines[2:]:
        start, end = line.split(" -> ")
        insertion_map[start] = end.replace("\n", "")
    return polymer, insertion_map


def insert_map_to_adj_map(insertion_map: Dict[str, str]) -> DefaultDict[str, List[str]]:
    """
    convert our insertion map to an adjacency map
    between polymer pairs
    """

    adj_map = defaultdict(lambda: [])
    for start, end in insertion_map.items():
        pair_1 = start[0] + end
        if pair_1 in insertion_map:
            adj_map[start] += [pair_1]
        pair_2 = end + start[1]
        if pair_2 in insertion_map:
            adj_map[start] += [pair_2]

    return adj_map


def to_num(c: str):
    return ord(c) - ord("A")


def to_letter(n: int):
    return chr(n + ord("A"))


def get_dp(adj_map: Dict[str, List[str]],
           insertion_map: Dict[str, str],
           n_steps: int,
           print_counts: bool = False) -> Dict[str, List[List[int]]]:
    """
    create dynamic programming dictionary where each pair
    maps to a list of letter counts built iteratively
    over n_steps - optionally print counts for debug
    """

    dp = {pair: [[0 for _ in range(26)]] for pair in adj_map}
    for pair in adj_map:
        dp[pair][0][to_num(pair[0])] += 1
        dp[pair][0][to_num(pair[1])] += 1

    for i in range(1, n_steps + 1):
        for pair, (left, right) in adj_map.items():
            left_counts = dp[left][i - 1]
            right_counts = dp[right][i - 1]
            new_counts = [left_counts[j] + right_counts[j] for j in range(26)]
            new_counts[to_num(insertion_map[pair])] -= 1
            dp[pair].append(new_counts)

    if print_counts:
        for pair in adj_map:
            print(f"Counts for pair {pair}")
            letter_counts = dp[pair][-1]
            for i in range(26):
                if letter_counts[i] > 0:
                    print(f"{to_letter(i)}: {letter_counts[i]}")

    return dp


def get_letter_counts(polymer: str,
                      dp: Dict[str, List[List[int]]],
                      print_counts: bool = False) -> List[int]:
    """
    based on our dynamic programming map, count
    occurrences of each letter generated by our polymer
    and optionally print for debug
    """

    letter_counts = [0 for _ in range(26)]
    for c_1, c_2 in zip(polymer, polymer[1:]):
        pair = c_1 + c_2
        if pair in dp:
            counts_for_pair = dp[pair][-1]
            letter_counts = [letter_counts[j] + counts_for_pair[j] for j in range(26)]
        else:
            letter_counts[to_num(c_1)] += 1
            letter_counts[to_num(c_2)] += 1

    for c in polymer[1:-1]:
        # remove double counts due to overlapping pairs
        letter_counts[to_num(c)] -= 1

    if print_counts:
        for i in range(26):
            if letter_counts[i] > 0:
                print(f"{to_letter(i)}: {letter_counts[i]}")

    return letter_counts


if __name__ == "__main__":

    with open("inputs/day14.txt") as input_file:
        data = input_file.readlines()

    start_polymer, insert_map = read_input(data)
    adjacency_map = insert_map_to_adj_map(insert_map)

    # do with 10 steps
    dp_map = get_dp(adjacency_map, insert_map, 10)
    l_counts = get_letter_counts(start_polymer, dp_map)
    l_counts = [n for n in l_counts if n > 0]
    print(max(l_counts) - min(l_counts))

    # now with 40 steps
    dp_map = get_dp(adjacency_map, insert_map, 40)
    l_counts = get_letter_counts(start_polymer, dp_map)
    l_counts = [n for n in l_counts if n > 0]
    print(max(l_counts) - min(l_counts))
